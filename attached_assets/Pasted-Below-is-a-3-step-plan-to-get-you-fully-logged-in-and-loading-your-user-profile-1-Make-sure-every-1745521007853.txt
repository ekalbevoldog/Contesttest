Below is a 3-step plan to get you fully logged in and loading your user profile:

1) Make sure every new Auth user has a database row

Right now you can sign up in Supabase Auth, but you never insert a matching row in your users table—so when you later select(...).single(), you get “0 rows” and bail.

In your registration endpoint (e.g. server/supabaseAuth.ts), after the signUp call add:

// pseudo-code in your register handler
const { data: signUpData, error: signUpErr } = 
  await supabase.auth.signUp({ email, password });
if (signUpErr) throw signUpErr;

const user = signUpData.user;
if (user) {
  const { error: insertErr } = await supabase
    .from('users')
    .insert({
      id:       user.id,           // Auth UID
      email:    user.email,
      role:     userMetadata.role, // whatever you passed
      fullName: userMetadata.fullName
    });
  if (insertErr) throw insertErr;
}
Now every Auth user will have a profile row—so your later fetch won’t return zero rows.

2) Swap your fetch-endpoint for direct Supabase JS (for session persistence)

If you call Supabase’s client library in the browser, it will automatically persist the JWT in localStorage (and rehydrate it on reload). That means useSupabaseAuth() can see a live session without you having to forward it from your own /api/auth/login route.

In your login handler, instead of:

// current: raw fetch to /api/auth/login
const response = await fetch('/api/auth/login', …);
do:

import { supabase } from '@/lib/supabase-client';

const { data, error } = await supabase.auth.signInWithPassword({
  email: values.email,
  password: values.password
});
if (error) {
  toast({ title: 'Login failed', description: error.message, variant: 'destructive' });
  return;
}
// at this point Supabase has stored the session in localStorage
// your useSupabaseAuth() hook will pick it up automatically
toast({ title: 'Login successful' });
navigateBasedOnRole(data.user);
And drop your custom /api/auth/login entirely (or leave it for SSR’d pages).

3) Make sure your client hook subscribes to Auth-state changes

In use-supabase-auth.tsx, do something like:

import { useState, useEffect } from 'react';
import { supabase } from '@/lib/supabase-client';

export function useSupabaseAuth() {
  const [session, setSession] = useState(supabase.auth.getSession());
  const [user,    setUser   ] = useState(session?.user ?? null);
  const [userData, setUserData] = useState(null);

  useEffect(() => {
    // rehydrate on reload
    const initial = supabase.auth.getSession();
    setSession(initial);
    setUser(initial?.user ?? null);

    // subscribe to future changes
    const {
      data: { subscription }
    } = supabase.auth.onAuthStateChange((_, newSession) => {
      setSession(newSession);
      setUser(newSession?.user ?? null);
      if (newSession?.user) fetchProfile(newSession.user.id);
    });

    return () => subscription.unsubscribe();
  }, []);

  async function fetchProfile(id: string) {
    const { data, error } = await supabase
      .from('users')
      .select('*')
      .eq('id', id)
      .single();           // <- always use .single() for one row
    if (error) return console.error('Profile load error', error);
    setUserData(data);
  }

  // on init, if we already had a session, load profile:
  useEffect(() => {
    if (user) fetchProfile(user.id);
  }, [user]);

  return {
    session,
    user,
    userData,
    signIn:  supabase.auth.signInWithPassword,
    signOut: supabase.auth.signOut,
    signUp:  supabase.auth.signUp
  };
}
Wrap-up
Insert a row in users at signup.
Sign in directly with supabase.auth.signInWithPassword() so the SDK persists the JWT.
Listen in your React hook to onAuthStateChange and .getSession() so user+userData stay live across page loads.
Once all three pieces are in place, you’ll get a real, persistent session—your dashboard will load, and you won’t be asked to log in again and again.